// Generated by CoffeeScript 1.8.0

/*
 * 读取和分析多个redis-cli info 信息，并对可能的问题进行报警
 */


/*
  需要的配置信息：
    server_name: 当前所在的服务器(报警时可使用)
    redis:(一个服务只检查一个redis， 如果一台服务器上有多个redis, 可以部署多个服务)
      host: -h
      port: -p

    slowlog:（慢查询报警得阀值）
      len:数量
      max_exec_time: 最大时长（如果有时长超过最大时长报警）

    info:
      used_memory
      used_memory_peak
      latest_fork_usec
      max_save_interval

  项目使用setTimeout 循环, 即在本次检查完成后确定下次的检查时间？
 */


/*
  需要做的检查：
    slowlog: 慢查询的检查（redis返回的查询时长单位是微秒， 默认超过10毫秒的就会记入慢查询）
      1. 当前慢查询的数量（默认最大128）redis-cli -h xxx -p xxx -r 1 slowlog len
      2. 将得到的慢查询写入日志文件中  redis-cli -h xxx -p xxx -r 1 slowlog get
      3. 检查完后清除掉slowlog（方便下次检查）

    info:
      1.内存的使用情况：（used_memory(使用内存) 和 used_memory_peak(峰值内存) ）
      2.持久化：（rdb_last_save_time 进行监控，了解你最近一次 dump 数据操作的时间(秒)。）
      3.fork性能：(通过对 info 输出的 latest_fork_usec 进行监控来了解最近一次 fork 操作导致了多少时间(毫秒)的卡顿。)

  将得到的查询写入日志文件并记录时间
  如果出现异常发送邮件通知
 */

(function() {
  var CMDS, CMD_KEYS, INFO, INTERVAL_TIME, LOG_PATH, REDIS, SLOWLOG, async, child_process, dateFormat, debuglog, fs, init, mailer, mkdirp, regExp, start, timeout, _, _validateInfo;

  fs = require("fs");

  async = require("async");

  child_process = require('child_process');

  _ = require('underscore');

  debuglog = require("debug")("redis_info");

  mkdirp = require("mkdirp");

  dateFormat = require('dateformat');

  mailer = require("./utils/mailer");

  regExp = new RegExp(/.+/g);

  REDIS = {
    host: '127.0.0.1',
    port: '6379'
  };

  SLOWLOG = {
    len: 32,
    max_exec_time: 10
  };

  INFO = {
    used_memory: 734003200,
    used_memory_peak: 1073741824,
    latest_fork_usec: 10000,
    max_save_interval: 1000
  };

  LOG_PATH = null;

  INTERVAL_TIME = 300000;

  CMDS = {};

  CMD_KEYS = null;

  _validateInfo = function(info, errs) {
    var latest_fork_usec, rdb_last_save_time, used_memory, used_memory_peak;
    if (_.isEmpty(info)) {
      errs.push("redis info is empty");
      return;
    }
    used_memory = parseInt(info.used_memory || 0);
    used_memory_peak = parseInt(info.used_memory_peak || 0);
    rdb_last_save_time = info.rdb_last_save_time;
    latest_fork_usec = parseInt(info.latest_fork_usec || 0);
    console.log("memory:" + used_memory + " memory_peak:" + used_memory_peak + " rdb_last_save_time:" + rdb_last_save_time + " latest_fork_usec:" + latest_fork_usec);
    if (used_memory > INFO.used_memory) {
      errs.push("redis info used_memory: " + used_memory);
    }
    if (used_memory_peak > INFO.used_memory_peak) {
      errs.push("redis info used_memory_peak: " + used_memory_peak);
    }
    if (latest_fork_usec > INFO.latest_fork_usec) {
      errs.push("redis info latest_fork_usec: " + latest_fork_usec);
    }
    if (new Date(rdb_last_save_time).getTime() < Date.now() - (INFO.max_save_interval * 1000)) {
      errs.push("redis info rdb_last_save_time: " + rdb_last_save_time);
    }
  };

  init = function(config) {
    var cmd_info, cmd_slowlog_get, cmd_slowlog_len, cmd_slowlog_reset;
    REDIS = config.REDIS || REDIS;
    SLOWLOG = config.SLOWLOG || SLOWLOG;
    INFO = config.INFO || INFO;
    LOG_PATH = config.log_path;
    INTERVAL_TIME = config.interval_time || INTERVAL_TIME;
    cmd_slowlog_len = "redis-cli -h " + REDIS.host + " -p " + REDIS.port + " -r 1 slowlog len";
    cmd_slowlog_get = "redis-cli -h " + REDIS.host + " -p " + REDIS.port + " -r 1 slowlog get";
    cmd_slowlog_reset = "redis-cli -h " + REDIS.host + " -p " + REDIS.port + " -r 1 slowlog reset";
    cmd_info = "redis-cli -h " + REDIS.host + " -p " + REDIS.port + " info";
    CMDS = {
      slowlogLen: cmd_slowlog_len,
      slowlogGet: cmd_slowlog_get,
      info: cmd_info
    };
    CMD_KEYS = _.keys(CMDS);
    mkdirp.sync(LOG_PATH);
  };

  timeout = null;

  start = function() {
    var infos;
    clearTimeout(timeout);
    infos = {};
    async.eachSeries(CMD_KEYS, (function(_this) {
      return function(key, next) {
        return child_process.exec(CMDS[key], function(err, stdout, stderr) {
          var arr, test;
          if (err != null) {
            return next(err);
          }
          if (key !== "info") {
            infos[key] = stdout;
          } else {
            arr = stdout.match(regExp) || [];
            test = {};
            arr.map(function(str) {
              var star;
              star = str.split(":");
              if (_.isArray(star) && star.length === 2) {
                return test[star[0]] = star[1];
              }
            });
            infos[key] = test;
          }
          return next();
        });
      };
    })(this), function(err) {
      var errs, info, slowlogLen;
      errs = [];
      if (err != null) {
        debuglog(err);
        errs.push(err);
      } else {
        slowlogLen = parseInt(infos.slowlogLen || 0);
        errs = [];
        if (slowlogLen >= SLOWLOG.len) {
          errs.push("slowlog len: " + slowlogLen);
        }
        info = infos.info;
        _validateInfo(infos.info, errs);
        console.log("log_path: " + LOG_PATH);
        fs.writeFileSync("" + LOG_PATH + "/info_" + (dateFormat(new Date(), "yyyymmddHHMMss")) + ".log", JSON.stringify(infos, null, 4));
        if (!_.isEmpty(errs)) {
          console.dir(errs);
          mailer.sendErrors(errs);
        }
        timeout = setTimeout(start, INTERVAL_TIME);
        return;
      }
    });
  };

  module.exports = {
    init: init,
    start: start
  };

}).call(this);
